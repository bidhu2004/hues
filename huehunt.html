<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChromaGuesser</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Space Grotesk Font from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300..700&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Space Grotesk', sans-serif;
            background-color: #e5e7eb; /* Light gray background */
            color: #111111; /* Black text for high contrast */
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            position: relative;
            overflow-x: hidden; /* Prevent horizontal scrolling */
            flex-direction: column; /* Ensure content stacks vertically */
            
            /* Background grid to emphasize structure */
            background-image:
                linear-gradient(to right, rgba(0, 0, 0, 0.1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(0, 0, 0, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        /* Raw, flat color blocks */
        .color-block {
            border: 8px solid #000000; /* Thicker border */
            background-color: #ffffff;
            transition: all 0.1s ease;
        }

        /* Custom color wheel styling */
        #colorWheelCanvas {
            cursor: crosshair;
            border: 8px solid #000000; /* Thicker border */
            /* Add this to prevent border collapse on some browsers */
            box-sizing: content-box;
        }

        /* Bold, pressable button style */
        .brutalist-button {
            background-color: #F34355;
            color: #ffffff;
            border: 4px solid #000000;
            box-shadow: 5px 5px 0 #000000;
            transition: all 0.1s ease-in-out;
            font-weight: bold;
        }
        .brutalist-button:hover {
            transform: translate(-3px, -3px);
            box-shadow: 8px 8px 0 #000000;
        }
        .brutalist-button:active {
            transform: translate(0, 0);
            box-shadow: 2px 2px 0 #000000;
        }

        /* Specific styles for the 'New Game' button */
        #newGameButton {
            background-color: #000000;
            color: #ffffff;
        }

        /* Styling for the massive top header bar */
        .top-header {
            width: 100%;
            background-color: #ffffff;
            border-bottom: 4px solid #000000;
            box-shadow: 0 4px 0 #000000;
        }
        
        /* Styling for the red section with scrolling text */
        .red-bar {
            background-color: #F34355;
            width: 100%;
            padding: 1.5rem 0; /* Increase padding for a larger bar */
            text-align: center;
            overflow: hidden;
            white-space: nowrap;
        }
        
        .scrolling-text-container {
            display: inline-block;
            white-space: nowrap;
            will-change: transform;
            animation: marquee 20s linear infinite;
        }
        
        @keyframes marquee {
            0% { transform: translateX(0%); }
            100% { transform: translateX(-50%); }
        }

        /* Styling for the black breaker line */
        .breaker-line {
            width: 100%;
            height: 4px;
            background-color: #000000;
        }

        /* Main content container for responsive layout */
        .main-content {
            padding: 2rem;
            max-width: 64rem;
            width: 100%;
        }

        @media (max-width: 640px) {
            .main-content {
                padding: 1rem;
            }
            .red-bar {
                padding: 1rem 0;
            }
            .text-6xl {
                font-size: 3rem;
            }
        }
        
        /* Brutalist footer style */
        .brutalist-footer {
            margin-top: 4rem;
            padding: 1rem;
            border-top: 4px solid #000000;
            text-align: center;
            font-size: 0.875rem;
            font-weight: bold;
            color: #000000;
            text-transform: uppercase;
        }
    </style>
</head>
<body class="p-0">
    <!-- Massive TAT Container (Oversized nav bar) -->
    <div class="top-header">
        <!-- Thick horizontal red section -->
        <div class="red-bar">
            <h1 class="text-3xl sm:text-4xl lg:text-5xl font-extrabold text-white uppercase tracking-wider leading-none">
                <span class="scrolling-text-container">
                    HueHunt // @visualsbybidharva &nbsp;&nbsp;&nbsp; HueHunt // @visualsbybidharva
                </span>
            </h1>
        </div>
    </div>
    <!-- Black horizontal breaker line -->
    <div class="breaker-line"></div>

    <!-- Main game content -->
    <div class="main-content flex-grow flex flex-col items-center justify-center relative z-10 mx-auto">
        <!-- Instructions -->
        <p class="text-gray-700 mb-8 max-w-md mx-auto text-lg text-center">
            Match the target color using the wheel to see how close you can get.
        </p>

        <!-- Game area: Target color and color wheel -->
        <div class="flex flex-col sm:flex-row items-center justify-around gap-8 mb-10 w-full">
            <!-- Target color block -->
            <div class="w-full sm:w-1/2">
                <div id="targetColorBlock" class="w-full h-48 sm:h-64 rounded-none color-block"></div>
                <p class="mt-4 text-base font-medium text-gray-700 text-center">Target Color</p>
            </div>
            
            <!-- Custom Color Wheel -->
            <div class="w-full sm:w-1/2 flex justify-center">
                <canvas id="colorWheelCanvas" width="250" height="250" class="rounded-full"></canvas>
            </div>
        </div>
        
        <!-- Feedback and buttons section -->
        <div class="space-y-8 w-full">
            <!-- User's guess color block -->
            <div id="userGuessBlock" class="w-full h-20 rounded-none color-block"></div>

            <!-- Feedback text -->
            <div id="feedback" class="text-2xl sm:text-3xl font-bold h-10 flex items-center justify-center text-black p-2 text-center">
                Ready to play?
            </div>

            <!-- Action buttons -->
            <div class="flex flex-col sm:flex-row gap-4">
                <button id="newGameButton" class="w-full text-xl py-4 px-8 rounded-none brutalist-button">
                    New Game
                </button>
                <button id="guessButton" class="w-full text-xl py-4 px-8 rounded-none brutalist-button">
                    Guess
                </button>
            </div>
        </div>
    </div>

    <!-- Brutalist footer -->
    <div class="brutalist-footer w-full mx-auto">
        <p>If you liked it, support me! Follow me on Instagram: <a href="https://www.instagram.com/visualsbybidharva" target="_blank" class="text-[#F34355] underline">@visualsbybidharva</a></p>
    </div>
    
    <script>
        // --- DOM Elements ---
        const targetColorBlock = document.getElementById('targetColorBlock');
        const userGuessBlock = document.getElementById('userGuessBlock');
        const colorWheelCanvas = document.getElementById('colorWheelCanvas');
        const ctx = colorWheelCanvas.getContext('2d');
        const guessButton = document.getElementById('guessButton');
        const newGameButton = document.getElementById('newGameButton');
        const feedback = document.getElementById('feedback');

        // --- Game State Variables ---
        let targetRgb = { r: 0, g: 0, b: 0 };
        let userRgb = { r: 255, g: 255, b: 255 };
        let isDragging = false;

        // --- Utility Functions ---

        /**
         * Converts HSL to RGB. HSL is easier for drawing the color wheel.
         * @param {number} h Hue (0-360).
         * @param {number} s Saturation (0-1).
         * @param {number} l Lightness (0-1).
         * @returns {{r: number, g: number, b: number}} The RGB color object.
         */
        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h / 360 + 1 / 3);
                g = hue2rgb(p, q, h / 360);
                b = hue2rgb(p, q, h / 360 - 1 / 3);
            }
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }

        /**
         * Converts an RGB color object to a hex string.
         * @param {{r: number, g: number, b: number}} rgb The RGB color object.
         * @returns {string} The hex color string.
         */
        function rgbToHex({ r, g, b }) {
            const componentToHex = (c) => {
                const hex = c.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            };
            return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
        }

        /**
         * Generates a random RGB color and returns it as an object.
         * @returns {{r: number, g: number, b: number}} The random RGB color.
         */
        function generateRandomColor() {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            return { r, g, b };
        }

        /**
         * Calculates the color difference using the Euclidean distance in RGB space.
         * A smaller distance means a closer match.
         * @param {{r: number, g: number, b: number}} color1 The first RGB color.
         * @param {{r: number, g: number, b: number}} color2 The second RGB color.
         * @returns {number} The distance between the two colors.
         */
        function calculateColorDistance(color1, color2) {
            const rDiff = color1.r - color2.r;
            const gDiff = color1.g - color2.g;
            const bDiff = color1.b - color2.b;
            return Math.sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff);
        }

        /**
         * Draws a triadic color wheel on the canvas.
         */
        function drawColorWheel() {
            const size = colorWheelCanvas.width;
            const centerX = size / 2;
            const centerY = size / 2;
            const radius = size / 2;
            const imageData = ctx.createImageData(size, size);
            const data = imageData.data;

            const primaryHues = [0, 120, 240]; // Red, Green, Blue
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angleRad = Math.atan2(dy, dx);
                    const angleDeg = (angleRad * 180 / Math.PI + 360) % 360;

                    if (dist <= radius) {
                        const saturation = dist / radius;
                        let hue = 0;

                        // Map angle to a triadic color scheme
                        if (angleDeg >= 0 && angleDeg < 120) {
                            // Interpolate between Red (0) and Green (120)
                            hue = 0 + (120 - 0) * (angleDeg / 120);
                        } else if (angleDeg >= 120 && angleDeg < 240) {
                            // Interpolate between Green (120) and Blue (240)
                            hue = 120 + (240 - 120) * ((angleDeg - 120) / 120);
                        } else {
                            // Interpolate between Blue (240) and Red (360)
                            hue = 240 + (360 - 240) * ((angleDeg - 240) / 120);
                        }
                        
                        const lightness = 0.5; // Constant lightness for a pure color wheel

                        const { r, g, b } = hslToRgb(hue, saturation, lightness);
                        const index = (y * size + x) * 4;
                        data[index] = r;
                        data[index + 1] = g;
                        data[index + 2] = b;
                        data[index + 3] = 255;
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        /**
         * Gets the color at a specific coordinate on the canvas.
         * @param {number} x The x coordinate.
         * @param {number} y The y coordinate.
         * @returns {{r: number, g: number, b: number} | null} The RGB color object or null.
         */
        function getColorFromCanvas(x, y) {
            const pixelData = ctx.getImageData(x, y, 1, 1).data;
            if (pixelData[3] === 0) return null; // Transparent pixel, outside the wheel
            return { r: pixelData[0], g: pixelData[1], b: pixelData[2] };
        }

        /**
         * Initializes a new game.
         */
        function newGame() {
            // Generate a new random target color
            targetRgb = generateRandomColor();
            
            // Set the target color block's background
            targetColorBlock.style.backgroundColor = rgbToHex(targetRgb);
            
            // Reset the user's guess block and feedback
            userRgb = { r: 255, g: 255, b: 255 }; // Reset to white
            userGuessBlock.style.backgroundColor = '#ffffff'; // A white background
            feedback.textContent = 'Ready to play?';
            drawColorWheel(); // Redraw the wheel
        }

        // --- Event Handlers ---
        
        /**
         * Handles mouse/touch down events on the color wheel.
         * @param {Event} e The event object.
         */
        function handleMouseDown(e) {
            isDragging = true;
            handleColorPick(e);
        }

        /**
         * Handles mouse/touch move events on the color wheel.
         * @param {Event} e The event object.
         */
        function handleMouseMove(e) {
            if (isDragging) {
                handleColorPick(e);
            }
        }

        /**
         * Handles mouse/touch up events on the color wheel.
         */
        function handleMouseUp() {
            isDragging = false;
        }

        /**
         * Handles the color picking logic from the canvas.
         * @param {Event} e The event object.
         */
        function handleColorPick(e) {
            const rect = colorWheelCanvas.getBoundingClientRect();
            let clientX, clientY;

            if (e.touches) { // Handle touch events
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else { // Handle mouse events
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const pickedColor = getColorFromCanvas(x, y);
            if (pickedColor) {
                userRgb = pickedColor;
                userGuessBlock.style.backgroundColor = rgbToHex(userRgb);
            }
        }

        /**
         * Handles the user's guess when the "Guess" button is clicked.
         */
        function handleGuess() {
            // Calculate the distance
            const distance = calculateColorDistance(targetRgb, userRgb);

            // Maximum possible distance is between (0,0,0) and (255,255,255)
            const maxDistance = Math.sqrt(255 * 255 + 255 * 255 + 255 * 255);
            
            // Calculate the percentage closeness
            const closeness = (1 - (distance / maxDistance)) * 100;
            
            feedback.textContent = `You are ${closeness.toFixed(2)}% close!`;
        }

        // --- Initialization ---

        // Add event listeners for the color wheel
        colorWheelCanvas.addEventListener('mousedown', handleMouseDown);
        colorWheelCanvas.addEventListener('mousemove', handleMouseMove);
        colorWheelCanvas.addEventListener('mouseup', handleMouseUp);
        colorWheelCanvas.addEventListener('mouseleave', handleMouseUp); // Stop dragging if cursor leaves canvas

        // Add touch event listeners for mobile support
        colorWheelCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling on touch
            handleMouseDown(e);
        }, { passive: false });
        colorWheelCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling on touch
            handleMouseMove(e);
        }, { passive: false });
        colorWheelCanvas.addEventListener('touchend', handleMouseUp);

        // Add event listeners to the buttons
        guessButton.addEventListener('click', handleGuess);
        newGameButton.addEventListener('click', newGame);
        
        // Start the first game when the page loads
        window.onload = function() {
            newGame();
        };

    </script>
</body>
</html>
